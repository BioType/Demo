<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js"></script>
<script>
'use strict';

var pako = window.pako;

// In browser

// Initial object //////////////////////////////////////////////////////////////

var obj = new Array(10);

for (var i = 0; i < obj.length; i++) {
  obj[i] = { foo: 'bar', baz: 'БАТ' };
}

// Convert /////////////////////////////////////////////////////////////////////

var str = JSON.stringify(obj);

//
// Now `str` is standard utf16 (16-bit) string. But we need 8-bit data
//

// Let's reencode to utf8
// This method is dirty, but simple and ok for example.
var data = unescape(encodeURIComponent(str));
console.log("initial data: ")
console.log(data)

// Compress ////////////////////////////////////////////////////////////////////

//
// After compression we have binary data (typed array here).
//
// `XMLHttpRequest.send` accepts typed arrays in modern browsers.
// For ancient ones - more work needed.
//

var resultAsUint8Array = pako.deflate(data);
console.log("resultAsUint8Array: ")
console.log(resultAsUint8Array)
var resultAsBinString  = pako.deflate(data, { to: 'string' });
console.log("resultAsBinString: ")
console.log(resultAsBinString)

// Send data to server
//
// Use multipart/form-data:
//
// - small overhead
// - well known format, easy to process anywhere
//
/////////////////////////////////////////////////////////

  var boundary = '----' + String(Math.random()).slice(2);

  var dataString = '';

  dataString += '--' + boundary + '\r\n';
  dataString += 'Content-Disposition: form-data; name="binson"; filename="blob"\r\n';
  dataString += 'Content-Type: application/octet-stream\r\n';
  dataString += 'Content-Transfer-Encoding: base64\r\n';
  dataString += '\r\n';
  dataString += btoa(resultAsBinString) + '\r\n';
  dataString += '--' + boundary + '--\r\n';
  console.log("data btoa: ")
  console.log(data)


</script>
</html>
<body>
Sending objects to server, run server code to see result.
</body>
